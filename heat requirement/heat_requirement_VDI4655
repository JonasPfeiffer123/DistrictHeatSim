import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

def import_TRY(filename):
    # Import TRY
    # Define column widths
    col_widths = [8, 8, 3, 3, 3, 6, 5, 4, 5, 2, 5, 4, 5, 5, 4, 5, 3]
    # Define column names
    col_names = ["RW", "HW", "MM", "DD", "HH", "t", "p", "WR", "WG", "N", "x", "RF", "B", "D", "A", "E", "IL"]

    # Read the file
    data = pd.read_fwf(filename, widths=col_widths, names=col_names, skiprows=34)

    # Store the columns as numpy arrays
    temperature = data['t'].values
    cloud_cover = data['N'].values

    return temperature, cloud_cover

def import_factors(filename):
    # Einlesen der CSV-Datei
    daten = pd.read_csv(filename, sep=';')  # oder sep=',' je nachdem, welches Trennzeichen Ihre CSV-Datei verwendet

    return daten

def generate_year_months_days_weekdays(year):
    # First day of the year
    start_date = np.datetime64(f'{year}-01-01')
    # Number of days in the year (consider leap year)
    num_days = 366 if np.datetime64(f'{year}-12-31') - np.datetime64(f'{year}-01-01') == np.timedelta64(365, 'D') else 365

    # Create an array with all days of the year
    days_of_year = np.arange(start_date, start_date + np.timedelta64(num_days, 'D'), dtype='datetime64[D]')
    # Extract month (values between 1 and 12)
    months = days_of_year.astype('datetime64[M]').astype(int) % 12 + 1
    # Extract day of the month
    days = days_of_year - days_of_year.astype('datetime64[M]') + 1

    # Extract weekday (Sunday=1, Saturday=7)
    weekdays = ((days_of_year.astype('datetime64[D]').astype(int) + 4) % 7) + 1

    return days_of_year, months, days, weekdays

def calculate_daily_averages(temperature, cloud_cover):
    # Assumption: The length of each array corresponds to the number of hours in a year
    num_hours = temperature.size
    num_days = num_hours // 24

    # Reshape the arrays to get daily data
    daily_temperature = temperature.reshape((num_days, 24))
    daily_cloud_cover = cloud_cover.reshape((num_days, 24))

    # Calculate daily averages
    daily_avg_temperature = np.mean(daily_temperature, axis=1)
    daily_avg_cloud_cover = np.mean(daily_cloud_cover, axis=1)

    return daily_avg_temperature, daily_avg_cloud_cover

def berechnung_lastgang(gebäudetyp, anzahl_personen_haushalt, JEB_Strom_kWh, 
                       JEB_Heizwärme_kWh, JEB_Trinkwarmwasser_kWh):


    # Klimazonen
    # Zone	Beschreibung
    #  1    Nordseeküste
    #  2    Ostseeküste
    #  3	Nordwestdeutsches Tiefland
    #  4	Nordostdeutsches Tiefland
    #  5	Niederrheinisch-westfälische Bucht und Emsland
    #  6	Nördliche und westliche Mittelgebirge, Randgebiete
    #  7	Nördliche und westliche Mittelgebirge, zentrale Bereiche
    #  8	Oberharz und Schwarzwald (mittlere Lagen)
    #  9	Thüringer Becken und Sächsisches Hügelland
    # 10	Südöstliches Mittelgebirge bis 1000m
    # 11	Ergebirge, Böhmer und Schwarzwald oberhalb 1000m
    # 12	Oberrheingraben und unteres Neckartal
    # 13	Schwäbisch-fränkisches Stufenland und Alpenvorland
    # 14	Schwäbische Alb und Baar
    # 15	Alpenrand und -täler

    # Betrachtetes Jahr: 
    year = 2019
    klimazone = "9"

    # Feiertage
    Neujahr = "2019-01-01"
    Karfreitag = "2019-04-19"
    Ostermontag = "2019-04-22"
    Maifeiertag = "2019-05-01"
    Pfingstmontag = "2019-05-30"
    Christi_Himmelfahrt = "2019-06-10"
    Fronleichnam = "2019-06-20"
    Tag_der_deutschen_Einheit = "2019-10-03"
    Allerheiligen = "2019-11-01"
    Weihnachtsfeiertag1 = "2019-12-25"
    Weihnachtsfeiertag2 = "2019-12-26"

    Feiertage = np.array([Neujahr, Karfreitag, Ostermontag, Maifeiertag, Pfingstmontag, 
                Christi_Himmelfahrt, Fronleichnam, Tag_der_deutschen_Einheit, 
                Allerheiligen, Weihnachtsfeiertag1, Weihnachtsfeiertag2]).astype('datetime64[D]')

    TRY = "heat requirement/TRY_511676144222/TRY2015_511676144222_Jahr.dat"
    factors = "heat requirement/VDI 4655 data/Faktoren.csv"

    # Erzeuge eine Liste mit allen Tagen für das Jahr 2019
    days_of_year, months, days, weekdays = generate_year_months_days_weekdays(2019)

    # Importiere die Wetterdaten
    temperature, bedeckungsgrad = import_TRY(TRY)
    daily_avg_temperature, daily_avg_bedeckungsgrad = calculate_daily_averages(temperature, bedeckungsgrad)
    
    jahreszeit = np.where(daily_avg_temperature < 5, "W", np.where((daily_avg_temperature >= 5) & (daily_avg_temperature <= 15), "Ü", "S"))
    tagart = np.where((weekdays == 1) | np.isin(days_of_year, Feiertage), "S", "W")
    bedeckungsgrad = np.where(jahreszeit == "S", "X", np.where((daily_avg_bedeckungsgrad >= 0) & (daily_avg_bedeckungsgrad < 4), "H", "B"))
    
    typtag = np.char.add(np.char.add(jahreszeit, tagart), bedeckungsgrad)
    Profiltag = np.char.add((gebäudetyp + klimazone), typtag)

    data = import_factors(factors)
    
    # Initialisiere leere Listen für die Ergebnisse
    f_heiz_tt_list = []
    f_el_tt_list = []
    f_tww_tt_list = []
    for tag in Profiltag:
        # Finde den Index des Profiltags im DataFrame
        index = np.where(data['Profiltag'] == tag)[0]

        f_heiz_tt_list.append(data.iloc[index]['Fheiz,TT'].values[0])
        f_el_tt_list.append(data.iloc[index]['Fel,TT'].values[0])
        f_tww_tt_list.append(data.iloc[index]['FTWW,TT'].values[0])

    # Konvertiere die Listen in Numpy-Arrays
    f_heiz_tt = np.array(f_heiz_tt_list)
    f_el_tt = np.array(f_el_tt_list)
    f_tww_tt = np.array(f_tww_tt_list)
    
    Tagesstrom = JEB_Strom_kWh * ((1/365) + (anzahl_personen_haushalt*f_el_tt))
    Tagesheizwärme = JEB_Heizwärme_kWh * f_heiz_tt
    Tages_WW = JEB_Trinkwarmwasser_kWh * ((1/365) + (anzahl_personen_haushalt*f_tww_tt))

    plt.plot(days_of_year, Tagesstrom)
    plt.plot(days_of_year, Tagesheizwärme)
    plt.plot(days_of_year, Tages_WW)

    plt.xlabel("day of year")
    plt.ylabel("täglicher Wärme- / Strombedarf in kWh")
    plt.show()

berechnung_lastgang("MFH", 3, 2000, 12000, 1500)