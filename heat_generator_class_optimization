import numpy as np
import pandas as pd
from scipy.optimize import minimize
from scipy.interpolate import RegularGridInterpolator
import matplotlib.pyplot as plt
from math import pi

class ConventionalHeatProducer:
    def __init__(self, name, max_capacity, min_load, efficiency, fuel_cost):
        self.name = name
        self.max_capacity = max_capacity
        self.min_load = min_load
        self.efficiency = efficiency
        self.fuel_cost = fuel_cost

    def calculate(self, load_L, VLT_L):
        raise NotImplementedError("Subclass must implement this method")

class HeatPump:
    def __init__(self, name, max_capacity, min_load, fuel_cost, source_temp, COP_data):
        self.name = name
        self.max_capacity = max_capacity
        self.min_load = min_load
        self.fuel_cost = fuel_cost
        self.source_temp = source_temp
        self.COP_data = COP_data

class WasteHeatPump:
    def __init__(self, name, cooling_load, min_load, fuel_cost, source_temp, COP_data):
        self.name = name
        self.min_load = min_load
        self.fuel_cost = fuel_cost
        self.source_temp = source_temp
        self.COP_data = COP_data
        self.cooling_load = cooling_load

    def calculate_COP(self, VLT_L):
        values = self.COP_data
        row_header = values[0, 1:]
        col_header = values[1:, 0]
        values = values[1:, 1:]
        f = RegularGridInterpolator((col_header, row_header), values, method='linear')
        VLT_L = np.minimum(VLT_L, 75)
        QT_array = np.full_like(VLT_L, self.source_temp)
        COP_L = f(np.column_stack((QT_array, VLT_L)))
        return COP_L
    
    def calculate(self, load_L, VLT_L):
        if self.cooling_load == 0:
            return 0, 0, np.zeros_like(load_L), np.zeros_like(VLT_L), 0
        
        COP_L = self.calculate_COP(VLT_L)
        heat_output_L = self.cooling_load / (1 - (1 / COP_L))
        el_power_L = heat_output_L - self.cooling_load

        heat_output_sum = np.sum(heat_output_L / 1000)
        el_power_sum = np.sum(el_power_L / 1000)

        max_heat_output = np.max(heat_output_L)

        return el_power_sum, heat_output_sum, heat_output_L

class Geothermal:
    def __init__(self, name, min_load, fuel_cost, source_temp, COP_data, area, borehole_depth, spec_drilling_cost=120, spec_extraction_power=50, full_usage_hours=2400, probe_distance=10):
        self.name = name
        self.min_load = min_load
        self.fuel_cost = fuel_cost
        self.source_temp = source_temp
        self.COP_data = COP_data
        self.area = area
        self.borehole_depth = borehole_depth
        self.spec_drilling_cost = spec_drilling_cost
        self.spec_extraction_power = spec_extraction_power
        self.full_usage_hours = full_usage_hours
        self.probe_distance = probe_distance
        self.max_capacity = 0

    def calculate_COP(self, VLT_L):
        values = self.COP_data
        row_header = values[0, 1:]
        col_header = values[1:, 0]
        values = values[1:, 1:]
        f = RegularGridInterpolator((col_header, row_header), values, method='linear')
        VLT_L = np.minimum(VLT_L, 75)
        QT_array = np.full_like(VLT_L, self.source_temp)
        COP_L = f(np.column_stack((QT_array, VLT_L)))
        return COP_L
    
    def calculate(self, load_L, VLT_L):
        COP_L = self.calculate_COP(VLT_L)

        if self.area == 0 or self.borehole_depth == 0:
            return 0, 0, np.zeros_like(load_L), np.zeros_like(VLT_L), 0, 0

        probe_area = (pi/4) * (2*self.probe_distance)**2
        number_of_probes = round(self.area / probe_area, 0)  # 22

        extraction_power_2400 = self.borehole_depth * self.spec_extraction_power * number_of_probes / 1000
        # kW for 2400 h, 22 probes, 50 W/m: 220 kW
        extracted_heat_amount = extraction_power_2400 * self.full_usage_hours / 1000  # MWh
        investment_costs_probes = self.borehole_depth * self.spec_drilling_cost * number_of_probes

        # The actual number of operating hours of the heat pump depends on the heat output,
        # which is related to the extraction power from the assumed number of operating hours
        B_min = 1
        B_max = 8760
        tolerance = 0.5
        while B_max - B_min > tolerance:
            B = (B_min + B_max) / 2
            # Calculate the extraction power
            extraction_power = extracted_heat_amount * 1000 / B  # kW
            # Calculate the heat output and electrical power
            heat_output_L = extraction_power / (1 - (1 / COP_L))
            electrical_power_L = heat_output_L - extraction_power

            # Determine the portion that is actually used
            portion = np.minimum(1, load_L / heat_output_L)

            # Calculate the actual values
            actual_heat_output_L = heat_output_L * portion
            actual_electrical_power_L = electrical_power_L * portion
            actual_extraction_power_L = actual_heat_output_L - actual_electrical_power_L
            extracted_heat = np.sum(actual_extraction_power_L) / 1000
            heat_amount = np.sum(actual_heat_output_L) / 1000
            electricity_demand = np.sum(actual_electrical_power_L) / 1000
            operating_hours = np.count_nonzero(actual_heat_output_L)

            # If there is no usage, the result is 0
            if operating_hours == 0:
                actual_heat_output_L = np.array([0])
                actual_electrical_power_L = np.array([0])

            if extracted_heat > extracted_heat_amount:
                B_min = B
            else:
                B_max = B

        max_heat_output = max(actual_heat_output_L)
        self.max_capacity = max_heat_output

        COP = heat_amount / electricity_demand

        return electricity_demand, heat_amount, actual_heat_output_L

class CHP(ConventionalHeatProducer):
    def __init__(self, name, max_capacity, min_load, efficiency, fuel_cost, electrical_efficiency):
        super().__init__(name, max_capacity, min_load, fuel_cost, efficiency)
        self.electrical_efficiency = electrical_efficiency

    def calculate(self, load_L, VLT_L):
        electrical_output_CHP = self.max_capacity*self.electrical_efficiency
        heat_output_CHP_L = np.where(load_L >= self.max_capacity, self.max_capacity, load_L)
        electrical_output_CHP_L = np.where(load_L >= self.max_capacity, electrical_output_CHP,
                                           electrical_output_CHP * (load_L / self.max_capacity))
        
        heat_output_CHP_sum = np.sum(heat_output_CHP_L / 1000)
        electrical_output_CHP_sum = np.sum(electrical_output_CHP_L / 1000)

        fuel_demand_sum = (heat_output_CHP_sum + electrical_output_CHP_sum) / self.efficiency

        return fuel_demand_sum, heat_output_CHP_sum, heat_output_CHP_L

class BiomassBoiler(ConventionalHeatProducer):
    def __init__(self, name, max_capacity, min_load, efficiency, fuel_cost):
        super().__init__(name, max_capacity, min_load, efficiency, fuel_cost)

    def calculate(self, load_L, VLT_L):
        heat_output_L = np.where(load_L >= self.max_capacity, self.max_capacity, load_L)
        total_heat= np.sum(heat_output_L / 1000)
        fuel_demand_sum = total_heat / self.efficiency
        return fuel_demand_sum, total_heat, heat_output_L

class GasBoiler(ConventionalHeatProducer):
    def __init__(self, name, max_capacity, min_load, efficiency, fuel_cost):
        super().__init__(name, max_capacity, min_load, efficiency, fuel_cost)

    def calculate(self, load_L, VLT_L):
        generated_heat_L = np.where(load_L >= self.max_capacity, self.max_capacity, load_L)
        total_heat = np.sum(generated_heat_L) / 1000
        fuel_demand_sum = total_heat / self.efficiency

        return fuel_demand_sum, total_heat, generated_heat_L

COP_data = np.loadtxt('heat_generators/Kennlinien WP.csv', delimiter=';')
waste_heat_pump = WasteHeatPump(name="Waste Heat Pump", cooling_load=50, min_load=0.5, fuel_cost=0.2, source_temp=5, COP_data=COP_data)
load = np.array([40, 50, 60])
VLT_L = np.array([70, 65, 60])
results = waste_heat_pump.calculate(load, VLT_L)
print(results)

geothermal = Geothermal(name="Geothermal", min_load=0.5, fuel_cost=0.2, source_temp=15, COP_data=COP_data, area=200, borehole_depth=200, spec_drilling_cost=120, spec_extraction_power=50, full_usage_hours=2400, probe_distance=10)
load = np.array([40, 50, 60])
VLT_L = np.array([70, 65, 60])
results = geothermal.calculate(load, VLT_L)
print(results)

chp = CHP(name="CHP Unit", max_capacity=20, min_load=0.5, efficiency=0.9, fuel_cost=0.05, electrical_efficiency=0.33)
load = np.array([120, 130, 140])
results = chp.calculate(load, VLT_L)
print(results)

biomass_boiler = BiomassBoiler(name="Biomass Boiler", max_capacity=100, min_load=0.3, efficiency=0.85, fuel_cost=0.08)
load = np.array([80, 90, 100])
results = biomass_boiler.calculate(load, VLT_L)
print(results)

gas_boiler = GasBoiler(name="Gas Boiler", max_capacity=150, min_load=0.3, efficiency=0.9, fuel_cost=0.05)
load = np.array([110, 115, 120])
results = gas_boiler.calculate(load, VLT_L)
print(results)


producers = [biomass_boiler, chp]

# Jahreslastgang aus CSV-Datei laden
load_profile = pd.read_csv('results_time_series_net.csv', delimiter=';', parse_dates=['Zeitpunkt'])
load_profile.set_index('Zeitpunkt', inplace=True)

# Function to calculate the operational cost of a heat producer
def calculate_operational_cost(producer, load, VLT):
    demand_sum, heat_sum, heat_L = producer.calculate(load, VLT)
    print(demand_sum, heat_sum)
    return demand_sum * producer.fuel_cost  # Modify this according to actual cost calculation

# Optimization function
def optimize_load_distribution(load, VLT, producers):
    # Objective function: Total costs
    def objective(x):
        return sum([calculate_operational_cost(producer, load, VLT) for producer, load in zip(producers, x)])
    
    # Constraints
    constraints = [{'type': 'eq', 'fun': lambda x: sum(x) - load}]  # Sum of loads must equal total load
    bounds = [(producer.min_load * producer.max_capacity, producer.max_capacity) for producer in producers]  # Capacity limits

    # Initial values
    initial_guess = [load / len(producers) for _ in producers]

    result = minimize(objective, initial_guess, method='SLSQP', bounds=bounds, constraints=constraints)
    return result.x if result.success else None

# Main function to execute optimization
def main(load_profile, producers):
    yearly_heating_demand = np.sum(load_profile)

    total_cost = 0
    load_distributions = {producer.name: [] for producer in producers}
    costs = []

    for time_step, row in load_profile.iterrows():
        total_load = row['Heizlast_Netz_kW']
        VLT = row['Vorlauftemperatur_Netz_°C']  # Assuming Vorlauftemperatur is available in load_profile
        optimal_load_distribution = optimize_load_distribution(total_load, VLT, producers)
        print(total_load)

        if optimal_load_distribution is not None:
            step_cost = sum([calculate_operational_cost(producer, load, VLT) for producer, load in zip(producers, optimal_load_distribution)])
            total_cost += step_cost

            # Store load distribution and costs
            for producer, load in zip(producers, optimal_load_distribution):
                load_distributions[producer.name].append(load)
            costs.append(step_cost / total_load)
        else:
            print(f"Time step {time_step}: No optimal solution found.")

        break

    # Plot-Erstellung
    plt.figure(figsize=(12, 6))
    plt.subplot(2, 1, 1)
    for producer in producers:
        plt.plot(time_step, load_distributions[producer.name], label=producer.name)
    plt.title('Lastverteilung über das Jahr')
    plt.ylabel('Last (kW)')
    plt.legend()

    plt.subplot(2, 1, 2)
    plt.plot(time_step, costs, label='Wärmegestehungskosten')
    plt.title('Kosten über das Jahr')
    plt.ylabel('Kosten in €/kWh')
    plt.xlabel('Zeit')

    plt.tight_layout()
    plt.show()

    print(f"Gesamtkosten für das Jahr: {total_cost:.3f} €")
    print(f"Gesamtkosten pro kWh über das Jahr: {total_cost/yearly_heating_demand:.3f} €/kWh")

if __name__ == "__main__":
    main(load_profile, producers)